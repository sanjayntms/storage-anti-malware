namespace AntiMalwareFunction.DataLake
{
    using System;
    using System.IO;
    using System.Threading.Tasks;
    using Azure;
    using Azure.Storage;
    using Azure.Storage.Files.DataLake;
    using Azure.Storage.Files.DataLake.Models;
    using Microsoft.AspNetCore.Http;
    using Microsoft.Extensions.Options;

    /// <summary>
    /// Class for executing Data Lake operations.
    /// </summary>
    public class DataLakeManager : IDataLakeManager
    {
        private DataLakeServiceClient _dataLakeServiceClient;

        /// <summary>
        /// Initializes a new instance of the <see cref="DataLakeManager"/> class.
        /// </summary>
        /// <param name="accountName">The Data Lake account name.</param>
        /// <param name="accountKey">The Data Lake account key.</param>
        /// <param name="serviceEndpoint">The Data Lake service endpoint.</param>
        public DataLakeManager(string accountName, string accountKey, string serviceEndpoint)
        {
            if (string.IsNullOrEmpty(accountName)
                || string.IsNullOrEmpty(accountKey)
                || string.IsNullOrEmpty(serviceEndpoint))
            {
                throw new ArgumentNullException("Required Data Lake configuration missing");
            }

            StorageSharedKeyCredential sharedKeyCredential =
                new StorageSharedKeyCredential(accountName, accountKey);
            _dataLakeServiceClient = new DataLakeServiceClient(new Uri(serviceEndpoint), sharedKeyCredential);
        }

        /// <inheritdoc />
        public async Task<DataLakeFile> DownloadFileAsync(string containerName, string filePath)
        {
            (_, string filename, _) = ParseFilePath(filePath);
            DataLakeFileClient fileClient = await GetDataLakeFileClientAsync(containerName, filePath);
            var pathProperties = await fileClient.GetPropertiesAsync().ConfigureAwait(false);
            Response<FileDownloadInfo> downloadResponse = await fileClient.ReadAsync().ConfigureAwait(false);

            DataLakeFile file = new DataLakeFile()
            {
                Filename = filename,
                ContentType = pathProperties.Value.ContentType,
                Content = downloadResponse.Value.Content,
            };

            return file;
        }

        /// <inheritdoc />
        public async Task<bool> DeleteFileAsync(string containerName, string filePath)
        {
            DataLakeFileClient fileClient = await GetDataLakeFileClientAsync(containerName, filePath);
            Response response = await fileClient.DeleteAsync().ConfigureAwait(false);
            return (response.Status == StatusCodes.Status200OK);
        }

        /// <summary>
        /// Gets the Data Lake file client for the given file.
        /// The method verifies that the file exists - otherwise an exception is thrown.
        /// </summary>
        /// <param name="containerName">The name of the Data Lake storage container.</param>
        /// <param name="filePath">The file path.</param>
        /// <returns>A newly created <see cref="DataLakeFileClient"/> instance.</returns>
        private async Task<DataLakeFileClient> GetDataLakeFileClientAsync(string containerName, string filePath)
        {
            if (string.IsNullOrEmpty(containerName))
            {
                throw new ArgumentNullException(nameof(containerName));
            }

            (_, string filename, string folderPath) = ParseFilePath(filePath);

            DataLakeDirectoryClient directoryClient = await GetDataLakeDirectoryClientAsync(
                containerName, folderPath).ConfigureAwait(false);

            DataLakeFileClient fileClient = directoryClient.GetFileClient(filename);

            if (!await fileClient.ExistsAsync().ConfigureAwait(false))
            {
                throw new FileNotFoundException($"File \"{filename}\" not found in container \"{containerName}\"");
            }

            return fileClient;
        }

        /// <summary>
        /// Gets the Data Lake directory client for the given path in the given container.
        /// </summary>
        /// <param name="containerName">The name of the Data Lake storage container.</param>
        /// <param name="folderPath">The folder path.</param>
        /// <returns>A newly created <see cref="DataLakeDirectoryClient"/> instance.</returns>
        private async Task<DataLakeDirectoryClient> GetDataLakeDirectoryClientAsync(
            string containerName, string folderPath)
        {
            DataLakeFileSystemClient fileSystemClient = _dataLakeServiceClient.GetFileSystemClient(containerName);

            if (!await fileSystemClient.ExistsAsync().ConfigureAwait(false))
            {
                throw new DirectoryNotFoundException($"Container \"{containerName}\" not found");
            }

            if (string.IsNullOrEmpty(folderPath))
            {
                return fileSystemClient.GetDirectoryClient(string.Empty);
            }

            DataLakeDirectoryClient directoryClient = null;
            string[] folderPathSegments = folderPath.Split('/');
            string currentPath = folderPathSegments[0];

            for (int i = 0; i < folderPathSegments.Length; ++i)
            {
                if (directoryClient == null)
                {
                    directoryClient = fileSystemClient.GetDirectoryClient(folderPathSegments[i]);
                }
                else
                {
                    directoryClient = directoryClient.GetSubDirectoryClient(folderPathSegments[i]);
                }

                if (!await directoryClient.ExistsAsync().ConfigureAwait(false))
                {
                    throw new DirectoryNotFoundException($"Directory \"{currentPath}\" not found in container \"{containerName}\"");
                }

                if (i < folderPathSegments.Length - 1)
                {
                    currentPath += "/" + folderPathSegments[i];
                }
            }

            return directoryClient;
        }

        /// <summary>
        /// Parses and cleans the given file path.
        /// </summary>
        /// <param name="filePath">The file path to parse and clean.</param>
        /// <returns>Cleaned file path, parsed filename and parsed folder path - in that order.</returns>
        private (string, string, string) ParseFilePath(string filePath)
        {
            if (string.IsNullOrEmpty(filePath))
            {
                throw new ArgumentNullException(nameof(filePath));
            }

            filePath = filePath
                .TrimStart('/')
                .Replace("\\", "/", StringComparison.CurrentCultureIgnoreCase);
            string filename = Path.GetFileName(filePath);
            string folderPath = Path.GetDirectoryName(filePath)
                .Replace("\\", "/", StringComparison.CurrentCultureIgnoreCase);

            return (filePath, filename, folderPath);
        }
    }
}
