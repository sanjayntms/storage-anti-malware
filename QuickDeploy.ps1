# Storage anti-malware solution quick deployment script
# -----------------------------------------------------
#
# - ONLY FOR TESTING
# - THE SCRIPT WILL OUTPUT SECRETS (DO NOT SHARE OUTPUT PUBLICALLY)
#
# See the README before use.

# Get ClamAV
.\Get-ClamAV.ps1

# Resource group for all resources
$ResourceGroupName = "storage-av-demo-rg"

# Get user object ID (for hash and for Key Vault access policy)
Write-Output "Retrieving Azure user object ID"
$UserObjectId = (az ad user list | ConvertFrom-Json)[0].objectId

# Generate hash from the user object ID for the resource name prefix
$Temp = [int[]][char[]]$UserObjectId
$UserObjectIdHash = 189
$Temp | Foreach-Object { $UserObjectIdHash += $_ }
Write-Output "Generated user object ID hash: $UserObjectIdHash"

# Prefix for the names of all resources
$ResourceNamePrefix = "storageavdemo" + $UserObjectIdHash

# Location (region) for all resources created
$Location = "westeurope"

$ServicePrincipalName = $ResourceNamePrefix + "sp"

$ApplicationInsightsName = $ResourceNamePrefix + "appinsights"
$LogAnalyticsWorkspaceName = $ResourceNamePrefix + "loganalytics"
$KeyVaultName = $ResourceNamePrefix + "kv"

# Storage account and container to monitor for malware
$StorageAccountName = $ResourceNamePrefix + "sa"
$StorageContainerName = "testcontainer"
$StorageAccountServiceEndpoint = "https://" + $StorageAccountName + ".dfs.core.windows.net/"

# Container registry for the ClamAV image
$ContainerRegistryName = $ResourceNamePrefix + "acr"
$ContainerRegistryLoginServerUri = $ContainerRegistryName + ".azurecr.io"

# The name of the container group in Azure Container Instances to run the ClamAV image in
$ContainerGroupName = $ResourceNamePrefix + "avaci"

$ContainerInstancesBaseUri = $ContainerGroupName + "." + $Location + ".azurecontainer.io"
$ClamAVContainerRepositoryName = "clamav"
$ClamAVContainerImage = $ContainerRegistryLoginServerUri + "/" + $ClamAVContainerRepositoryName + ":latest"

# The name of the Azure Function App monitoring the storage account
$AntiMalwareFunctionAppName = $ResourceNamePrefix + "avaf"

# The notification settings for an event when malware is detected
# The solution will work even if the Office/Outlook settings are not configured properly,
# but will throw an error in the logs
$MalwareNotificationRecipients = "dick.hallorann@overlookhotel.com,jack.torrance@overlookhotel.com"
$SmtpServer = "smtp.office365.com"
$SmtpPort = "587"
$SmtpDomain = "outlook.com"
$SmtpUsername = "admin@overlookhotel.com"
$SmtpPassword = "donotcommitrealpwdtorepo"


# Create service principal
Write-Output "Creating Service Principal"

$ServicePrincipalDetails = az ad sp create-for-rbac --name $ServicePrincipalName | ConvertFrom-Json
$ServicePrincipalAppId = $ServicePrincipalDetails[0].appId
$ServicePrincipalPassword = $ServicePrincipalDetails[0].password
$ServicePrincipalTenantId = $ServicePrincipalDetails[0].tenant
$ServicePrincipalObjectId = (az ad sp list --spn $ServicePrincipalAppId | ConvertFrom-Json)[0].objectId

Write-Output "Service principal (app ID, object ID, password, tenant ID): $ServicePrincipalAppId $ServicePrincipalObjectId $ServicePrincipalPassword $ServicePrincipalTenantId"

# Create resource group
Write-Output "Creating Resource Group"

az group create `
    --location $Location `
    --name $ResourceGroupName

# Create Log Analytics
Write-Output "Creating Log Analytics"

az deployment group create `
    --name LogAnalytics `
    --resource-group $ResourceGroupName `
    --template-file arm-templates\log_analytics.json `
    --parameters `
        logAnalyticsWorkspaceName=$LogAnalyticsWorkspaceName `
        location=$Location `
        sku=pergb2018 `
        diagnosticSettingName=setByPipeline

# Create Application Insights
Write-Output "Creating Application Insights"

az deployment group create `
    --name ApplicationInsights `
    --resource-group $ResourceGroupName `
    --template-file arm-templates\app_insights.json `
    --parameters `
        name=$ApplicationInsightsName `
        type="web" `
        location=$Location `
        requestSource="rest" `
        logAnalyticsWorkspaceName=$LogAnalyticsWorkspaceName

# Create Key Vault
Write-Output "Creating Key Vault"

az deployment group create `
    --name KeyVault `
    --resource-group $ResourceGroupName `
    --template-file arm-templates\key_vault.json `
    --parameters `
        keyVaultName=$KeyVaultName `
        location=$Location `
        servicePrincipalId=$ServicePrincipalAppId `
        servicePrincipalObjectId=$ServicePrincipalObjectId `
        sku="Standard" `
        enabledForDeployment=true `
        enabledForTemplateDeployment=true `
        enabledForDiskEncryption=true `
        enableRbacAuthorization=false `
        enableSoftDelete=true `
        softDeleteRetentionInDays=7 `
        logAnalyticsWorkspaceName=$LogAnalyticsWorkspaceName `
        diagnosticSettingName=setByPipeline

# Add Key Vault access policy and create required secrets
Write-Output "Configuring Key Vault"

az keyvault set-policy `
    --name $KeyVaultName `
    --secret-permissions delete, get, list, recover, restore, set `
    --object-id $UserObjectId

az keyvault secret set `
    --name "smtpUsername" `
    --vault-name $KeyVaultName `
    --disabled false `
    --encoding utf-8 `
    --value $SmtpUsername

az keyvault secret set `
    --name "smtpPassword" `
    --vault-name $KeyVaultName `
    --disabled false `
    --encoding utf-8 `
    --value $SmtpPassword

# Create Storage Account (Data Lake Gen2)
Write-Output "Creating Storage Account (Data Lake Gen2)"

az deployment group create `
    --name StorageAccount `
    --resource-group $ResourceGroupName `
    --template-file arm-templates\data_lake.json `
    --parameters `
        location=$Location `
        storageAccountName=$StorageAccountName `
        storageContainerName=$StorageContainerName `
        accountType="Standard_LRS" `
        kind="StorageV2" `
        accessTier="Hot" `
        supportsHttpsTrafficOnly=true `
        allowBlobPublicAccess=false `
        networkAclsBypass="AzureServices" `
        networkAclsDefaultAction="Allow" `
        isHnsEnabled=true `
        keyVaultName=$KeyVaultName `

# Create Container Registry
Write-Output "Creating Azure Container Registry"

az deployment group create `
    --name ContainerRegistry `
    --resource-group $ResourceGroupName `
    --template-file arm-templates\container_registry.json `
    --parameters `
        containerRegistryName=$ContainerRegistryName `
        location=$Location `
        sku="Standard" `
        logAnalyticsWorkspaceName=$LogAnalyticsWorkspaceName `
        diagnosticSettingName=setByPipeline

# Login to Azure Container Registry
Write-Output "Logging in to Azure Container Registry"
az acr login --name $ContainerRegistryName

# Build and push ClamAV image
Write-Output "Build ClamAV Docker image"
docker build -t $ClamAVContainerImage .\clamav-container\
Write-Output "Pushing ClamAV Docker image to ACR"
docker push $ClamAVContainerImage

# Create Azure Container Instances
Write-Output "Creating Azure Container Instances"

az deployment group create `
    --name AzureContainerInstances `
    --resource-group $ResourceGroupName `
    --template-file arm-templates\aci_antimalware.json `
    --parameters `
        containerRegistryName=$ContainerRegistryName `
        containerGroupName=$ContainerGroupName `
        location=$Location `
        dnsNameLabel=$ContainerGroupName `
        clamAVContainerName=$ClamAVContainerRepositoryName `
        clamAVContainerImage=$ClamAVContainerImage `
        clamAVPort=3310

# Build and packaging Function application source and package the result
Write-Output "Building and packaging Function application source"

dotnet publish .\src\AntiMalwareFunction\AntiMalwareFunction.sln --configuration Release

$CompressPath = $PSScriptRoot + "\src\AntiMalwareFunction\AntiMalwareFunction\bin\Release\netcoreapp3.1\publish\*"
$AntiMalwarePackagePath = $PSScriptRoot + "\AntiMalwareFunction.zip"

Compress-Archive `
    -Path $CompressPath `
    -DestinationPath $AntiMalwarePackagePath `
    -Force

# Get storage account secrets from Key Vault
$StorageAccountKey = (az keyvault secret show --name dataLakePrimaryKey --vault-name $KeyVaultName | ConvertFrom-Json)[0].value
$StorageAccountConnectionString = (az keyvault secret show --name dataLakeConnectionString --vault-name $KeyVaultName | ConvertFrom-Json)[0].value

# Create Azure Function application
Write-Output "Creating Azure Function application"

az deployment group create `
    --name AzureFunctionApp `
    --resource-group $ResourceGroupName `
    --template-file arm-templates\azure_function_antimalware.json `
    --parameters `
        functionAppName=$AntiMalwareFunctionAppName `
        location=$Location `
        clamAVServerUri=$ContainerInstancesBaseUri `
        clamAVPort=3310 `
        dataLakeAccountName=$StorageAccountName `
        dataLakeAccountKey=$StorageAccountKey `
        dataLakeConnectionString=$StorageAccountConnectionString `
        dataLakeServiceEndpoint=$StorageAccountServiceEndpoint `
        dataLakeContainerName=$StorageContainerName `
        smtpServer=$SmtpServer `
        smtpPort=$SmtpPort `
        smtpDomain=$SmtpDomain `
        smtpUsername=$SmtpUsername `
        smtpPassword=$SmtpPassword `
        notificationSender=$SmtpUsername `
        notificationRecipients=$MalwareNotificationRecipients `
        applicationInsightsName=$ApplicationInsightsName `
        logAnalyticsWorkspaceName=$LogAnalyticsWorkspaceName `
        diagnosticSettingName=setByPipeline

# Deploy the built anti-malware app package
Write-Output "Deploying Azure Function"

az functionapp deployment source config-zip `
    --resource-group $ResourceGroupName `
    --name $AntiMalwareFunctionAppName `
    --src $AntiMalwarePackagePath

Write-Output "Finished"
